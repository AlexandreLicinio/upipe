
@section TPH {Overview}

  Upipe provides an extensive set of header files, to be used by pipes and
  applications. Applications will also generally want to link with optional
  libraries, which allow to create and manage some core data structures.

  @section T {Data structures}

    Upipe's data structures can be classified into four groups, as shown by the following graph which depicts dependancy relationships between structures (dashed lines are optional):

    @image dependancies.png

    @section {Core structures}

      Core structures provide services for all other groups:

      @list

        @item atomic operations with or without locks (@ref uatomic_uint32_t)
        @item reference counters (@ref urefcount)
        @item chained lists (@ref uchain and @ref ulist) and rings allowing pointer tagging (@ref uring)
        @item lock-less LIFOs (@ref ulifo) without thread limitations
        @item lock-less FIFOs (@ref ufifo) without thread limitations
        @item lock-less buffer queues (@ref uqueue) without thread limitations
        @item lock-less exclusive access to non-reentrant resources (@ref udeal)
        @item objects to pass event information between threads (@ref ueventfd)
        @item dictionaries storing key/value pairs (@ref udict)
        @item memory allocation with or without pools (@ref umem)
        @item access to monotonic or real-time system clock (@ref uclock)

      @end list

    @end section

    @section {Buffer management}

      Buffer management structures define how data is carried across inside a pipeline and are handled by @ref ubuf and associated managers. These structures typically point to a shared, reference counted area maintained by the manager. Upipe natively supports two types of buffers, each with a dedicated API to access and modify data :

      @list

        @item blocks (arbitrary octet content with arbitrary and variable size), typically used for encoded data: @ref ubuf_block_alloc ; the API supports windowing and resizing blocks, as well as merging and cutting out with zero-copy and copy-on-write semantics.
        @item pictures, defined by their chromatic planes, pixel sizes and subsampling, with arbitrary width and height: @ref ubuf_pic_alloc.

      @end list

      Pipes and applications however do not manipulate @ref ubuf directly, but @ref uref, which is composed of a pointer to @ref ubuf and a pointer to @ref udict. The dictionary allows to associate arbitrary attributes to the @ref ubuf.

      An attribute is defined by a name (string), a type and a value. Attribute names start by convention with a letter indicating the category of the attribute, and a dot. Categories are for instance b for block allocator, p for picture allocator, c for clocks, f for flow information, or x for custom attributes. The standard inline udict manager includes a list of common attribute names defined as "shorthands", which are stored and retrieved more efficiently.

      The standard Upipe distribution provides managers for block and picture formats, relying on application memory allocation (malloc). They in turn use the @ref umem_mgr facility to allocate buffer spaces.

    @end section

    @section {Pipes}

      Pipes are provided by specialized modules, possibly delivered by third-parties. A @ref upipe may expose input and control methods (with standard and custom commands), and would typically take data from its input, process it and output it, possibly using a different buffer, to its output. Functions from a pipe may only be called from a single thread, so locking and reentrancy isn't required.

      When created, pipes are passed with one structure for logging and sending exceptions (@ref uprobe) to the parent code upon certain events (end of file, fatal error, new flow, etc.), and optional arguments, in particular, for pipes that aren't sources, a flow definition packet of type @ref uref describing the input. Pipe allocation is performed with @ref upipe_void_alloc or @ref upipe_flow_alloc, depending whether the pipe requests a flow definition packet. A few pipes may also provide their own specific allocator.

      The standard Upipe distribution currently contains the following pipe types (though third-party modules may also be used):

      @table 3

        @item API name @item description @item link with

        @item @ref upipe_fsrc_mgr_alloc @item source pipe opening for reading a file or special file characterized by its path @item @tt -lupipe-modules
        @item @ref upipe_fsink_mgr_alloc @item sink pipe opening for writing a file or special file characterized by its path @item @tt -lupipe-modules
        @item @ref upipe_udpsrc_mgr_alloc @item source pipe opening for reading a UDP socket @item @tt -lupipe-modules
        @item @ref upipe_multicat_sink_mgr_alloc @item sink pipe opening for writing a directory in a manner compatible with multicat @item @tt -lupipe-modules
        @item @ref upipe_dup_mgr_alloc @item split pipe allowing to duplicate all input packets to several outputs @item @tt -lupipe-modules
        @item @ref upipe_qsrc_mgr_alloc (also note @ref upipe_qsrc_alloc) @item source pipe opening a thread-safe queue with one or more qsink pipes @item @tt -lupipe-modules
        @item @ref upipe_qsink_mgr_alloc @item sink pipe sending buffers to a queue opened by a qsrc pipe @item @tt -lupipe-modules
        @item @ref upipe_null_mgr_alloc @item sink pipe destroying all input buffers @item @tt -lupipe-modules
        @item @ref upipe_proxy_mgr_alloc @item pipe acting as a proxy in front of a split pipe @item @tt -lupipe-modules
        @item @ref upipe_setattr_mgr_alloc @item pipe setting given attributes on all incoming buffers @item @tt -lupipe-modules
        @item @ref upipe_genaux_mgr_alloc @item pipe generating multicat-style auxiliary blocks @item @tt -lupipe-modules
        @item @ref upipe_multicat_sink_mgr_alloc @item sink pipe generating multicat-style directories @item @tt -lupipe-modules
        @item @ref upipe_avfsrc_mgr_alloc @item source pipe opening for reading a URL and using libavformat @item @tt -lupipe-av
        @item @ref upipe_sws_mgr_alloc @item linear pipe scaling a flow of pictures using libswscale @item @tt -lupipe-sws
        @item @ref upipe_ts_demux_mgr_alloc @item split pipe demultiplexing a TS stream (also features lots of subpipes) @item @tt -lupipe-ts
        @item @ref upipe_mp2vf_mgr_alloc @item pipe gathering MPEG-1 and MPEG-2 video streams into frames @item @tt -lupipe-framers

      @end table

      Data is fed into a pipe using @ref upipe_input. The @ref uref argument then belongs to the callee and shouldn't be used any longer. There is an additional @ref upump argument that points to the pump that generated the buffer (or NULL if unavailable).

      The generic @ref upipe_control call provides to the application an interface to modify the pipe's property. The counterpart of this function is provided by @ref uprobe, which allows the pipe to send messages to the application. It is possible to build upon this messaging system to dynamically take actions on the pipe or the pipeline. All parameters to @ref upipe_control belong to the caller. All parameters to sent by subpipes via probes also belong to the subpipe. The standard Upipe distribution currently contains the following catchers:

      @table 3

        @item API name @item description @item link with

        @item @ref uprobe_stdio_alloc @item print all log messages to a file stream @item @tt -lupipe
        @item @ref uprobe_pfx_alloc @item prefix all log messages with the given name @item @tt -lupipe
        @item @ref uprobe_log_alloc @item log all received events, for debug purposes @item @tt -lupipe
        @item @ref uprobe_ts_log_alloc @item log TS-related received events, for debug purposes @item @tt -lupipe-ts
        @item @ref uprobe_upump_mgr_alloc @item set a upump manager on pipes that throw @ref UPROBE_NEED_UPUMP_MGR @item @tt -lupipe
        @item @ref uprobe_uref_mgr_alloc @item set a uref manager on pipes that throw @ref UPROBE_NEED_UREF_MGR @item @tt -lupipe
        @item @ref uprobe_selprog_alloc @item select programs according to criteria @item @tt -lupipe
        @item @ref uprobe_dejitter_alloc @item dejitter packets coming from a network by averaging reference clocks @item @tt -lupipe

      @end table

      In Upipe's design, decision taking happens inside probes, while data processing is done in pipes with no intelligence whatsoever.

      Control commands and pipes are classified (that is, enum values are prepended with a prefix) into 7 categories:

      @list

        @item generic: commands and probes which can apply to any type of pipe (no prefix)
        @item source: for pipes that have no input, but rely instead on external events to retrieve incoming data
        @item join: for pipes that have several inputs, such as a mux
        @item split: for pipes that have several outputs, such as a demux
        @item sink: for pipes that have no output and may rely on external events
        @item void: for pipes that have neither input nor output (such a pipe may be used internally to create other pipes)
        @item pipe type-specific commands and probes which must be prefixed with the short name of the pipe

      @end list

      As a convenience, the Upipe distribution provides a number of "helper" macros which usually manage internal structures and control commands:

      @table 2

        @item helper macro @item description

        @item @ref #UPIPE_HELPER_UPIPE @item very basic helper providing the @tt {upipe_foo_from_upipe} and @tt {upipe_foo_to_upipe} functions on which most helpers rely
        @item @ref #UPIPE_HELPER_VOID @item helper for pipes which require no argument to their allocation function
        @item @ref #UPIPE_HELPER_FLOW @item helper for pipes which require a flow definition packet to be passed as argument to their allocation function
        @item @ref #UPIPE_HELPER_UREF_MGR @item helper for pipes which require a uref manager
        @item @ref #UPIPE_HELPER_UPUMP_MGR @item helper for pipes which require a upump manager and rely on external events
        @item @ref #UPIPE_HELPER_UCLOCK @item helper for pipes which requires a uclock
        @item @ref #UPIPE_HELPER_OUTPUT @item helper for the management of the output
        @item @ref #UPIPE_HELPER_UBUF_MGR @item helper for the management of the ubuf manager for the output
        @item @ref #UPIPE_HELPER_SOURCE_READ_SIZE @item helper for source pipes reading data in chunks of a configuration size
        @item @ref #UPIPE_HELPER_SINK_DELAY @item helper for sink pipes outputting data at the given system time of packets, plus a configurable delay
        @item @ref #UPIPE_HELPER_UREF_STREAM @item helper for pipes reading data octet by octet, for instance to constitute packets or frames
        @item @ref #UPIPE_HELPER_SUBPIPE @item helper for split pipes and join pipes to manage their subpipes
        @item @ref #UPIPE_HELPER_BIN @item helper for bin pipes (that incorporate a sub-pipeline of several pipes)
        @item @ref #UPROBE_HELPER_UPROBE @item very basic helper providing the @tt {uprobe_foo_from_uprobe} and @tt {uprobe_foo_to_uprobe} functions on which most helpers rely
        @item @ref #UPROBE_HELPER_ADHOC @item helper for automatic allocation and deallocation of probes bound to a single pipe

      @end table

      Strictly speaking, a @ref upipe object has at most one input and one output (and possibly none). Split and join pipes are implemented using subpipes: the main split (resp. join) pipe is a sink (resp. a source), and each output (resp. input) requires allocating a source (resp. sink) subpipe using @ref upipe_void_alloc_sub or @ref upipe_flow_alloc_sub, depending whether the subpipe requests a flow definition. In a split pipe, outputs are configured with @ref upipe_set_output, @ref upipe_set_flow_def and @ref upipe_set_ubuf_mgr called on the output subpipe; however data is fed into the main pipe. In a join pipe, data is input using @ref upipe_input on each input subpipe; however outputs are configured on the main pipe. The caller must therefore keep a constellation of objects, not only the main pipe but also all the subpipes. Outputs (resp. inputs) are closed by calling @ref upipe_release on the related subpipe.

    @end section

    @section {External events}

      Source pipes and sink pipes (but not exclusively) rely on external events to retrieve or dispatch data. For instance, one may want to wait on a UDP socket for packets. Or to wait until a system pipe (mkfifo) can be written again. Or more simply, wait for a timeout.

      Pipes which need those interactions can create pumps with the built-in primitives. The @ref upump abstraction layer then maps the events to the API of the event loop which is used by the application. It supports the following types of events:

      @list

        @item idlers are executed whenever there is nothing else to do: @ref upump_alloc_idler
        @item timers are executed after a given timeout: @ref upump_alloc_timer
        @item read (resp. write) file descriptor watchers are executed whenever data is ready to be read from (resp. written to) a file descriptor: @ref upump_alloc_fd_read (resp. @ref upump_alloc_fd_write)

      @end list

      It is expected that more event types get added in the future, especially for Microsoft Windows(tm)-specific objects. Some core objects, which require being able to wait on a condition, propose their own API to allocate an adequate upump (@ref uqueue_upump_alloc_pop or @ref udeal_upump_alloc). In turn, they rely on the @ref ueventfd object provided by Upipe.

      When creating a pump, the pipe must specify whether it would operate as a source, ie. whether the call-back would output packets to outgoing modules. A sink pipe which can no longer write to its output may block the whole pipeline, and in that case pumps marked as sources will be temporarily disabled.

      Upipe currently provides abstraction layers for these event loops:

      @table 3

        @item event loop @item API @item link with

        @item libev @item @ref upump_ev_mgr_alloc @item @tt -lupump-ev -lev

      @end table

    @end section

  @end section

  @section T {Managers}

    To deal with structures efficiently, Upipe has a notion of "managers", which are similar to factories in object-oriented programming. Consequently, @ref ubuf are created by a @ref ubuf_mgr, @ref udict by @ref udict_mgr, @ref uref by @ref uref_mgr, @ref upump by @ref upump_mgr and @ref upipe by @ref upipe_mgr. Managers typically deal with memory pools or hardware resources such as access to video memory or hardware decoding.

    Upipe provides standard implementations of @ref ubuf_mgr (for blocks and pictures), @ref udict_mgr, @ref umem_mgr and @ref uref_mgr in the libupipe library (link with -lupipe).

    The @ref upump_mgr implementations are supplied by dedicated, API-specific libraries such as libupump-ev. Finally, @ref upipe_mgr managers allow to create the pipes themselves and are either provided by the libupipe-modules library for standard pipes, or by third-party libraries.

    To instanciate managers it is necessary to link with some libraries; however there is no dependancy associated with the use of the children structures @ref ubuf, @ref uref and @ref upump, as all code is either provided by inline functions or function pointers. Libraries providing implementations of @ref upipe_mgr and @ref upipe usually do not depend on libupipe.

    Upon initialization, a new pipe may be passed the managers for its @ref uref, @ref ubuf and @ref upump structures, if it requires to create them. If it has no need for a manager (for instance it just changes an attribute to all uref structures passing by), then it need not be passed.

  @end section

  @section T {Clocks}

    All timestamps in Upipe are represented, by convention, as ticks of a 27 MHz clock. The origin and pace of the clock depends on the nature of the timestamp:

    @list

      @item sysdate timestamps are expressed using the monotonic or real-time clock of the system; they are typically used for bridging flows from different sources with different clocks, or for sinks
      @item pts timestamps are expressed using a fictional monotonic clock retrieved from the input stream; they must not contain gaps and do not loop; they must start at a "high-enough" value so that all values are positive (by convention 2^33)
      @item pts_orig timestamps are directly retrieved from the input source; they are typically used when one wants to remux a stream with the exact same timestamps

    @end list

  @end section

@end section
